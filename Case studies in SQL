-- Case1:

# AVAILABLE SEATS

You have a restaurant with 1,000 seats. Whenever a waiter puts 
someone at a seat, he logs it in a table of seats (I was going to say “table
of tables” and make this impossible to read). Likewise, when a guest
finishes a meal, you remove the guest’s seat number. You want to write a
query to produce a list of the available seats in the restaurant, set up in
blocks by their starting and ending seat numbers. Oh yes, the gimmick
is that the database resides on a personal digital assistant and not a
mainframe computer.

As part of the exercise, you must do this with the smallest amount of
storage possible. Assume each seat number is an integer.

The first thought is to add a (free/occupied) flag column next to the
seat-number column. The available seating query would be based on the
flag. This would be 1,000 rows of one integer and one character for the
whole restaurant and would work pretty well, but we have that minimal
storage requirement. Darn! 

Answer:
SELECT (R1.seat + 1) AS start,
 (MIN(R2.seat) - 1) AS finish
 FROM Restaurant AS R1
 INNER JOIN
 Restaurant AS R2
 ON R2.seat > R1.seat
 GROUP BY R1.seat
HAVING (R1.seat + 1) < MIN(R2.seat);


--------------------


-- Case 2:

# Top Salespeople

The three biggest sales and salespeople in each district. Let’s use this data:
SalesData district_nbr sales_person sales_id sales_amt
==========================================
 1 'Curly' 5 3.00
 1 'Harpo' 11 4.00
 1 'Larry' 1 50.00
 1 'Larry' 2 50.00
 1 'Larry' 3 50.00
 1 'Moe' 4 5.00
 2 'Dick' 8 5.00
 2 'Fred' 7 5.00
 2 'Harry' 6 5.00
 2 'Tom' 7 5.00
 3 'Irving' 10 5.00
 3 'Melvin' 9 7.00
 4 'Jenny' 15 20.00
 4 'Jessie' 16 10.00
 4 'Mary' 12 50.00
 4 'Oprah' 14 30.00
 4 'Sally' 13 40.00
 

Answer:
Unfortunately, there are some problems in the specification we got. Do
we want the three largest sales (regardless of who made them) or the top
three salespeople? There is a difference—look at district 1, where 'Larry'
made all three of the largest sales, but the three best salespeople were
'Larry', 'Moe', and 'Harpo'.
What if more than three people sold exactly the same amount, as in
district 2? If a district has less than three salespeople working in it, as in
district 3, do we drop it from the report or not? Let us make the decision,
since this is just a puzzle and not a production system, that the boss
meant the three largest sales in each district, without regard to who the
salespeople were. That query can be:

SELECT *
 FROM SalesData AS S0
 WHERE sales_amt IN (SELECT S1.sales_amt
 FROM SalesData AS S1
 WHERE S0.district_nbr = S1.district_nbr
 AND S0.sales_amt <= S1.sales_amt
 HAVING COUNT(*) <= 3)
 ORDER BY S0.district_nbr, S0.sales_person, S0.sales_id,
S0.sales_amt;

Results:
district_nbr sales_person sales_id sales_amt
====================================
 1 'Larry' 1 50.00
 1 'Larry' 2 50.00
 1 'Larry' 3 50.00
 3 'Irving' 10 5.00
 3 'Melvin' 9 7.00
 4 'Mary' 12 50.00
 4 'Oprah' 14 30.00
 4 'Sally' 13 40.00
 
Now what if we wanted the top three salespeople in their districts,
without regard to how many people were assigned to each district? We
could modify the query like this:

SELECT DISTINCT district_nbr, sales_person
 FROM SalesData AS S0
 WHERE sales_amt <= (SELECT MAX(S1.sales_amt)
 FROM SalesData AS S1
 WHERE S0.district_nbr = S1.district_nbr
 AND S0.sales_amt <= S1.sales_amt
 HAVING COUNT(DISTINCT S0.sales_amt) <= 3);
 
and get these results. Please notice that you are getting the three largest
sales.

Results:
district_nbr sales_person
====================
 1 'Harpo'
 1 'Moe'
 1 'Larry'
 2 'Dick'
 2 'Fred'
 2 'Harry'
 2 'Tom'
 3 'Irving'
 3 'Melvin'
 4 'Oprah'
 4 'Sally'
 4 'Mary'
 
Notice that four people are tied for the top three sales positions in
district 2. Likewise, the lack of competition in district 3 gave us two
salespeople in the top three. 


--------------------


-- Case 3:

# One in Ten

Let's assume you ran into a problem with some legacy system data that
had been moved over to an SQL database. The table looked like this:

 CREATE TABLE MyTable
 (keycol INTEGER NOT NULL,
 f1 INTEGER NOT NULL,
 f2 INTEGER NOT NULL,
 f3 INTEGER NOT NULL,
 f4 INTEGER NOT NULL,
 f5 INTEGER NOT NULL,
 f6 INTEGER NOT NULL,
 f7 INTEGER NOT NULL,
 f8 INTEGER NOT NULL,
 f9 INTEGER NOT NULL,
 f10 INTEGER NOT NULL);
 
The columns f1 through f10 were an attempt to flatten out an array
into a table. What he wanted was an elegant way to test against the f1
through f10 columns to find the rows that had exactly one nonzero
value in their columns.

How many different approaches can you find? We are looking for
variety and not performance. 

Answer:
#1 
You could use the SIGN() function in Sybase and other SQL products.
This function returns -1, 0, or +1 if the argument is negative, zero, or
positive, respectively. Assuming that your numbers are zero or greater,
you simply write:

 SELECT *
 FROM MyTable
 WHERE SIGN(f1) + SIGN(f2) + ... + SIGN(f10) = 1;
 
to find a single nonzero value. If you can have negative values, then make
the functions SIGN(ABS(fn)).

The SIGN(ABS()) function combination can be written with the
CASE expression in SQL-92 as:
 CASE WHEN x <> 0 THEN 1 ELSE 0 END
 
#2
This depends on a feature of SQL-92 that is not generally available yet.
First, the code, then the explanation:

SELECT *
 FROM MyTable
 WHERE (f1, f2, ... , f10) IN
 (VALUES (f1, 0, 0, 0, 0, 0, 0, 0, 0, 0),
 (0, f2, 0, 0, 0, 0, 0, 0, 0, 0),
 ....
 (0, 0, 0, 0, 0, 0, 0, 0, 0, f10))
 AND (f1 + f2 + ... f10) > 0;

In SQL-92, you can use row and table constructors in comparison
predicates. The IN predicate expands into a sequence of OR-ed equality
predicates. The row-wise version of equality is then done on a positionby-position basis, 
where all corresponding values must be equal.

#3
If one and only one column is nonzero, then there is a one set of nine
columns that are all zeros.

SELECT *
 FROM MyTable
 WHERE 0 IN
 (VALUES (f2 + f3 + .. f10), -- pull out f1
 (f1 + f3 + .. f10), -- pull out f2
 ...
 (f1 + f2 + .. f9)) -- pull out f10
 AND (f1 + f2 + ... f10) > 0; 

#4
SELECT *
 FROM MyTable
 WHERE
(f1+1)*(f2+1)*(f3+1)*(f4+1)*(f5+1)*(f6+1)*(f7+1)*(f8+1)*(f9
+1)*(f10+1)*(f2+1)= 2


--------------------


-- Case 4:

# 
